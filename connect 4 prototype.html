<!DOCTYPE html>
<html>
<head>
    <title>game</title>
</head>
<style>
    body {
        background-color: #DDD;
        font-family: Helvetica;
        font-size: 40pt;
    }
    #content {
        display: flex;
        justify-content: center;
        align-items: center;
    }
    #boardsContainer {
        display: flex;
        flex-direction: column-reverse;
        perspective: 1000px;
        perspective-origin: 150px 1000px;
        margin-top: 200px;
    }
    .board {
        transform: rotateX(20deg);
        margin-top: -50%;
        background-color: rgba(255, 255, 255, 0.5);
        font-size: 100pt;


        display: inline-grid;
        grid-template-columns: 100px 100px 100px;
        grid-template-rows: 100px 100px 100px;
        height: 300px;
        width: 300px;
        border: 1px solid black;
    }
    .board > div {
        height: 100px;
        width: 100px;
        display: flex;
        justify-content: center;
        align-items: center;
        border: 1px solid black;
    }
</style>
<script>
"use strict"
window.addEventListener("load", () => {

    let player = 0

    window.gameState = [
        [[null, null, null], [null, null, null], [null, null, null]],
        [[null, null, null], [null, null, null], [null, null, null]],
        [[null, null, null], [null, null, null], [null, null, null]]
    ]

    let clickTimeout = false

    const handleClick = e => {

        // Avoid accidental double click activation
        if (clickTimeout) {
            return
        }


        let {boardIndex, tileX, tileY} = e.target.dataset

        if (gameState[boardIndex][tileY][tileX] != null) return

        while (boardIndex>0 && gameState[boardIndex-1][tileY][tileX] == null) {
            boardIndex--
        }

        gameState[boardIndex][tileY][tileX] = player

        const tile = boards[boardIndex].children[parseInt(tileY)*3 + parseInt(tileX)]
        tile.innerHTML = "•"
        tile.style.color = player ? "red" : "blue"

        if (checkGameStatus(boardIndex, tileY, tileX, player)) {
            player = ++player%2
            playerNum.innerHTML = "•"
            playerNum.style.color = player ? "red" : "blue"
        } else {
            playerNum.innerHTML = "• wins"
        }

        clickTimeout = true
        setTimeout(() => clickTimeout = false, 250)
    }

    // Check axes of last placed item
    const checkGameStatus = (boardIndex, tileY, tileX, player) => {

        let match = false
        const max = gameState[0].length-1
        const mid = Math.floor(max/2)

        boardIndex = parseInt(boardIndex)
        tileY = parseInt(tileY)
        tileX = parseInt(tileX)

        // Check current board
        match = gameState[boardIndex][tileY].every(col => col==player) // Horizontal
            ||  gameState[boardIndex].every(row => row[tileX]==player) // Vertical
            ||  ((tileX + tileY)%2 == 0 && ( // is it on a diagonal?
                    // Diagonal top-left -> bottom-right
                    gameState[boardIndex].every((row, ri) => row[ri]==player) ||
                    // Diagonal bottom-left -> top-right
                    gameState[boardIndex].every((row, ri) => row[max-ri]==player)
                ))

        // Check other boards
        // up/down
        match = match || gameState.every(board => board[tileY][tileX] == player)

        if (match) return false

        // 3D diagonals
        // Not in location unreachable by a diagonal
        if (boardIndex != mid || (boardIndex==mid && (tileY==mid || tileX==mid))) {

            match = match
                ||  gameState.every((board, bi) => board[max-bi][tileX]==player) // near-bottom -> far-top
                ||  gameState.every((board, bi) => board[bi][tileX]==player) // far-bottom -> near-top
                ||  gameState.every((board, bi) => board[tileY][max-bi]==player) // bottom-left -> top-right
                ||  gameState.every((board, bi) => board[tileY][bi]==player) // bottom-right -> top-left

            if (match) return false

            // Check cross diagonal (going from corners through the middle)
            if (gameState[mid][mid][mid]==player) {

                match = match
                    ||  gameState.every((board, bi) => board[bi][bi]==player) // far-bottom-left -> near-top-right
                    ||  gameState.every((board, bi) => board[max-bi][bi]==player) // near-bottom-left -> far-top-right
                    ||  gameState.every((board, bi) => board[max-bi][max-bi]==player) // near-bottom-right -> far-top-left
                    ||  gameState.every((board, bi) => board[bi][max-bi]==player) // far-bottom-right -> near-top-left
            }
        }

        console.log("match", match, "\n\n")

        return !match
    }


    const boards = Array.from(document.querySelectorAll(".board"))
    boards.forEach((board, bi) => {
        const tiles = Array.from(board.querySelectorAll("div"))

        tiles.forEach((tile, ti) => {
            tile.dataset.boardIndex = bi
            tile.dataset.tileX = ti%3
            tile.dataset.tileY = parseInt(ti/3)

            tile.addEventListener("click", handleClick)
        })
    })


    let rotating = false
    let direction = -1
    let rotationValue = 0

    const rotate = () => {

        boards.forEach(board => {
            rotationValue += direction
            board.style.transform = `rotateX(20deg) rotateZ(${rotationValue}deg)`
        })

        if (rotating) {
            setTimeout(rotate, 10)
        }
    }


    window.addEventListener("keydown", (e) => {

        if (e.code=="ArrowLeft") {
            rotating = true
            direction = -1
            rotate()
        } else if (e.code=="ArrowRight") {
            rotating = true
            direction = 1
            rotate()
        }
    })

    window.addEventListener("keyup", () => rotating = false)
})

</script>
<body>

Player: <span id="playerNum" style="color:blue">•</span><br><br>

<div id="content">
    <div id="boardsContainer">
        <div class="board">
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
        </div>
        <div class="board">
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
        </div>
        <div class="board">
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
        </div>
    </div>
</div>


</body>
</html>