"use strict";const test="stuff";class GameBoard{constructor(game){const{span:span,gameState:gameState,gravity:gravity,gravityEnabled:gravityEnabled}=game;this.playerColours=["blue","red","green","purple","yellow","brown","black","cyan","pink","darkgrey"],this.rotationValue=-45,this.tiltValue=3==span?20:7==span?40:30,this.span=span,this.gravity=gravity,this.gravityEnabled=gravityEnabled,this.perspectiveX=150,this.perspectiveY=1e3,this.boardElement=document.createElement("div"),this.boardElement.id="boardsContainer",3!=this.span&&(this.boardElement.style.marginTop="0",7==this.span?(this.boardElement.style.marginTop="100px",this.perspectiveY=800):this.perspectiveY=1e3),this.boardElement.style.perspectiveOrigin=`${this.perspectiveX}px ${this.perspectiveY}px`;for(let b=0;b<this.span;b++){const board=document.createElement("div"),tileSize=300/this.span;board.className="board",board.style.gridTemplateColumns=`${tileSize}px `.repeat(this.span),board.style.gridTemplateRows=`${tileSize}px `.repeat(this.span),board.style.transform=`rotateX(${this.tiltValue}deg) rotateZ(${this.rotationValue}deg)`,board.style.marginTop=7==this.span?"-70%":"-50%",flatArrowsContainer.style.transform=`rotateX(${this.tiltValue+30}deg) rotateZ(${this.rotationValue-45}deg)`;for(let r=0;r<this.span;r++)for(let c=0;c<this.span;c++){const tile=document.createElement("div");tile.addEventListener("click",()=>game.makeMove(game.playerIndex,b,r,c)),tile.addEventListener("mouseover",()=>this.styleHoverPreview(b,r,c)),board.appendChild(tile)}this.boardElement.appendChild(board)}}render(gameState){for(let b=0;b<this.span;b++)for(let r=0;r<this.span;r++)for(let c=0;c<this.span;c++){const elem=this.boardElement.children[b].children[r*this.span+c];null==gameState[b][r][c]?elem.innerHTML="":(elem.innerHTML="•",elem.style.color=this.playerColours[gameState[b][r][c]])}}addPoint(board,row,col,player){this.boardElement.children[board].children[row*this.span+col].innerHTML="•",this.boardElement.children[board].children[row*this.span+col].style.color=this.playerColours[player]}renderPoints(){}resetBoard(){for(let b=0;b<this.span;b++)this.boardElement.children[board].children[r*this.span+c].innerHTML=""}styleHoverPreview(board,row,col){if(!this.gravityEnabled)return;switch(this.boardElement.querySelectorAll(".hoveredTile").forEach(tile=>tile.classList.toggle("hoveredTile")),this.gravity.axis){case 0:for(let b=0;b<this.span;b++)this.boardElement.children[b].children[row*this.span+col].classList.toggle("hoveredTile");break;case 1:for(let c=0;c<this.span;c++)this.boardElement.children[board].children[row*this.span+c].classList.toggle("hoveredTile");break;case 2:for(let r=0;r<this.span;r++)this.boardElement.children[board].children[r*this.span+col].classList.toggle("hoveredTile")}}rotate(){Array.from(this.boardElement.children).forEach(board=>{board.style.transform=`rotateX(${this.tiltValue}deg) rotateZ(${this.rotationValue}deg)`,flatArrowsContainer.style.transform=`rotateX(${this.tiltValue+30}deg) rotateZ(${this.rotationValue-45}deg)`})}}class GameLogic{constructor({gameState:gameState,gravityEnabled:gravityEnabled=!0,span:span=3,players:players=2,isTraining:isTraining=!1,isMultiplayer:isMultiplayer=!1}={}){this.players=[],this.gravityEnabled=gravityEnabled,this.span=parseInt(span),this.numPlayers=parseInt(players),this.isTraining=isTraining,this.isMultiplayer=isMultiplayer,this.gameState=gameState||this.resetGame(),this.gravity={axis:0,modifier:-1},this.directions={up:0,down:0,left:1,right:1,forward:2,backward:2},this.modifiers={up:1,down:-1,left:-1,right:1,forward:-1,backward:1},this.board=new GameBoard(this),playerNum.style.color=this.board.playerColours[this.playerIndex],this.isTraining?this.players.push(new GamePlayer("AI",0)):this.players.push(new GamePlayer("local human",0));for(let p=1;p<players;p++)this.isTraining?this.players.push(new GamePlayer("AI",p)):isMultiplayer?this.players.push(new GamePlayer("remote human",p)):this.players.push(new GamePlayer("local human",p));this.playerIndex=Math.floor(Math.random()*players)}resetGame(){const gameState=[];for(let b=0;b<this.span;b++){const boardGameState=[];for(let r=0;r<this.span;r++){const rowGameState=[];for(let c=0;c<this.span;c++)rowGameState.push(null);boardGameState.push(rowGameState)}gameState.push(boardGameState)}return this.board&&(this.board.resetBoard(),playerNum.style.color=this.board.playerColours[this.playerIndex]),winsDisplay.style.display="none",gameState}makeMove(p,b,r,c){if(console.log("makeMove",p,b,r,c),p==this.playerIndex){if(null!=this.gameState[b][r][c])return this.players[p].reward(-100,this.gameState),void this.players[p].pickMove(this.gameState);if([b,r,c]=this.applyGravityToMove(b,r,c),this.gameState[b][r][c]=p,this.board.addPoint(b,r,c,p),this.winningMove(b,r,c,p))return this.players[p].reward(1,this.gameState),this.players.forEach((player,pi)=>pi!=p&&player.reward(-1,this.board)),winsDisplay.style.display="inline-block",void(this.isTraining&&this.resetGame());if(this.isFull())return this.players.forEach((player,pi)=>player.reward(.25,this.board)),void(this.isTraining&&this.resetGame());this.players.forEach((player,pi)=>pi!=p&&player.reward(0,this.board)),this.playerIndex=++this.playerIndex%this.players.length,playerNum.style.color=this.board.playerColours[this.playerIndex],winsDisplay.style.display="none",this.players[this.playerIndex].pickMove(this.board)}}winningMove(boardIndex,tileY,tileX,player){let match=!1;const max=this.gameState[0].length-1,mid=Math.floor(max/2);if(match=(match=this.gameState[boardIndex][tileY].every(col=>col==player)||this.gameState[boardIndex].every(row=>row[tileX]==player)||(tileX+tileY)%2==0&&(this.gameState[boardIndex].every((row,ri)=>row[ri]==player)||this.gameState[boardIndex].every((row,ri)=>row[max-ri]==player)))||this.gameState.every(board=>board[tileY][tileX]==player))return!0;if(boardIndex!=mid||boardIndex==mid&&(tileY==mid||tileX==mid)){if(match=match||this.gameState.every((board,bi)=>board[max-bi][tileX]==player)||this.gameState.every((board,bi)=>board[bi][tileX]==player)||this.gameState.every((board,bi)=>board[tileY][max-bi]==player)||this.gameState.every((board,bi)=>board[tileY][bi]==player))return!0;this.gameState[mid][mid][mid]==player&&(match=match||this.gameState.every((board,bi)=>board[bi][bi]==player)||this.gameState.every((board,bi)=>board[max-bi][bi]==player)||this.gameState.every((board,bi)=>board[max-bi][max-bi]==player)||this.gameState.every((board,bi)=>board[bi][max-bi]==player))}return match}isFull(){for(let b=0;b<this.span;b++)for(let r=0;r<this.span;r++)for(let c=0;c<this.span;c++)if(null==this.gameState[b][r][c])return!1;return!0}getAvailableMoves(){}applyGravityToMove(board,row,col){if(!this.gravityEnabled)return[board,row,col];let counts;switch(this.gravity.axis){case 0:counts=-1==this.gravity.modifier?board:this.span-1-board;for(let i=0;i<counts&&null==this.gameState[board+this.gravity.modifier][row][col];i++)board+=this.gravity.modifier;break;case 1:counts=-1==this.gravity.modifier?col:this.span-1-col;for(let i=0;i<counts&&null==this.gameState[board][row][col+this.gravity.modifier];i++)col+=this.gravity.modifier;break;case 2:counts=-1==this.gravity.modifier?row:this.span-1-row;for(let i=0;i<counts&&null==this.gameState[board][row+this.gravity.modifier][col];i++)row+=this.gravity.modifier}return[board,row,col]}shiftGravity(direction){this.gravity.axis=this.directions[direction],this.gravity.modifier=this.modifiers[direction];const max=Math.abs((-1==this.gravity.modifier?this.span-1:0)-(this.span-1));switch(this.gravity.axis){case 0:for(let r=0;r<this.span;r++)for(let c=0;c<this.span;c++){let i2=0;everyBoard:for(let i=0;i<this.span;i++)if(null==this.gameState[Math.abs(max-i)][r][c]){for(i2=i+1;i2<this.span;)i2<this.span&&i<this.span&&null!=this.gameState[Math.abs(max-i2)][r][c]&&(this.gameState[Math.abs(max-i)][r][c]=this.gameState[Math.abs(max-i2)][r][c],this.gameState[Math.abs(max-i2)][r][c]=null,i+=i2),i2++;break everyBoard}}break;case 1:for(let b=0;b<this.span;b++)for(let r=0;r<this.span;r++){let i2=0;everyColumn:for(let i=0;i<this.span;i++)if(null==this.gameState[b][r][Math.abs(max-i)]){for(i2=i+1;i2<this.span;)i2<this.span&&i<this.span&&null!=this.gameState[b][r][Math.abs(max-i2)]&&(this.gameState[b][r][Math.abs(max-i)]=this.gameState[b][r][Math.abs(max-i2)],this.gameState[b][r][Math.abs(max-i2)]=null,i+=i2),i2++;break everyColumn}}break;case 2:for(let b=0;b<this.span;b++)for(let r=0;r<this.span;r++){let i2=0;everyColumn:for(let i=0;i<this.span;i++)if(null==this.gameState[b][Math.abs(max-i)][r]){for(i2=i+1;i2<this.span;)i2<this.span&&i<this.span&&null!=this.gameState[b][Math.abs(max-i2)][r]&&(this.gameState[b][Math.abs(max-i)][r]=this.gameState[b][Math.abs(max-i2)][r],this.gameState[b][Math.abs(max-i2)][r]=null,i+=i2),i2++;break everyColumn}}}this.board.render(this.gameState),this.checkAll()}checkAll(){let player,match=!1;for(let b=0;b<this.span;b++)for(let r=0;r<this.span;r++)for(let c=0;c<this.span;c++)if(null!=this.gameState[b][r][c]&&(match=match||this.winningMove(b,r,c,this.gameState[b][r][c]))){player=this.gameState[b][r][c];break}match?(playerNum.style.color=this.board.playerColours[player],winsDisplay.style.display="inline-block"):(this.playerIndex=++this.playerIndex%this.players.length,winsDisplay.style.display="none",playerNum.style.color=this.board.playerColours[this.playerIndex])}insertMoveAt(){}}class GamePlayer{constructor(type,playerIndex){console.log(`new ${type} player: ${playerIndex}`),this.type=type}getQ(){}pickMove(){this.type}reward(){this.type}}
//# sourceMappingURL=game.min.js.map