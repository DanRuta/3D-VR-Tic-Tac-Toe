"use strict";class GameBoard{constructor(game){const{span:span,gravity:gravity,gravityEnabled:gravityEnabled}=game;this.playerColours=["blue","red","green","purple","yellow","orange","black","cyan","pink","darkgrey"],this.rotation=-45,this.span=span,this.gravity=gravity,this.gravityEnabled=gravityEnabled,this.BOX_WIDTH=.5,this.SPREAD=Math.floor(this.span/2),this.SPACING=1.5,this.SPHERE_RADIUS=.2,this.SPHERE_V_COUNT=50,this.OPACITY_ON=.5,this.OPACITY_OFF=.25,this.explodedMult=1,this.isLerpingBoxes=!1,this.colours={RED:16711680,BLUE:255,GREEN:65280,PURPLE:8913032,YELLOW:16776960,ORANGE:16737792,BLACK:0,CYAN:65535,PINK:16761035,LIGHTGREY:10066329,DARKGREY:7829367,WHITE:16777215},this.scene=new THREE.Scene,this.camera=new THREE.PerspectiveCamera(75,window.innerWidth/window.innerHeight,.1,1e3),this.raycaster=new THREE.Raycaster,this.mouse=new THREE.Vector2,this.renderer=new THREE.WebGLRenderer({alpha:!0,antialias:!0}),this.renderer.setPixelRatio(window.devicePixelRatio),this.renderer.setSize(window.innerWidth-100,window.innerHeight-200),this.boardElement=this.renderer.domElement;const light=new THREE.DirectionalLight(this.colours.LIGHTGREY,1);light.position.set(1,1,1).normalize(),this.scene.add(light),this.camera.position.y=2;const previewSphereGeometry=new THREE.SphereGeometry(this.SPHERE_RADIUS,this.SPHERE_V_COUNT,this.SPHERE_V_COUNT),previewSphereMaterial=new THREE.MeshLambertMaterial({color:this.colours.RED,transparent:!0});previewSphereMaterial.opacity=0,previewSphereMaterial.emissive.setHex(this.colours.RED),this.previewSphere=new THREE.Mesh(previewSphereGeometry,previewSphereMaterial),this.scene.add(this.previewSphere),console.log("HERE",this),this.initBoards(),this.renderLoop(),this.rotate(),this.boardElement.addEventListener("mousemove",event=>{this.mouse.x=event.clientX/window.innerWidth*2-1,this.mouse.y=-event.clientY/window.innerHeight*2+1},!1)}initBoards(){this.highlightedBoxes=[],this.boxes=[...new Array(this.span)].map(()=>[...new Array(this.span)].map(()=>[...new Array(this.span)])),this.spheres=[...new Array(this.span)].map(()=>[...new Array(this.span)].map(()=>[...new Array(this.span)]));for(let b=0;b<this.span;b++)for(let r=0;r<this.span;r++)for(let c=0;c<this.span;c++)this.addBox(b,r,c)}addBox(b,r,c){const geometry=new THREE.BoxGeometry(this.BOX_WIDTH,this.BOX_WIDTH,this.BOX_WIDTH),material=new THREE.MeshLambertMaterial({color:this.colours.DARKGREY});material.opacity=this.OPACITY_OFF,material.transparent=!0;const box=new THREE.Mesh(geometry,material);box.material.emissive.setHex(this.colours.LIGHTGREY),box.position.x=(r-this.SPREAD)*this.BOX_WIDTH*this.SPACING,box.position.y=(b-this.SPREAD)*this.BOX_WIDTH*this.SPACING,box.position.z=(c-this.SPREAD)*this.BOX_WIDTH*this.SPACING,box.data={b:b,r:r,c:c},box.origPos={x:box.position.x,y:box.position.y,z:box.position.z},this.scene.add(box),this.boxes[b][r][c]=box}addSphere(b,r,c,colour){const sphereGeometry=new THREE.SphereGeometry(this.SPHERE_RADIUS,this.SPHERE_V_COUNT,this.SPHERE_V_COUNT),sphereMaterial=new THREE.MeshLambertMaterial({color:this.colours[colour.toUpperCase()]}),sphere=new THREE.Mesh(sphereGeometry,sphereMaterial);sphere.material.emissive.setHex(this.colours[colour.toUpperCase()]),sphere.position.x=(r-this.SPREAD)*this.BOX_WIDTH*this.SPACING,sphere.position.y=(b-this.SPREAD)*this.BOX_WIDTH*this.SPACING,sphere.position.z=(c-this.SPREAD)*this.BOX_WIDTH*this.SPACING,sphere.origPos={x:sphere.position.x,y:sphere.position.y,z:sphere.position.z},this.spheres[b][r][c]=sphere,this.scene.add(sphere)}clearHighlightedBoxes(){for(let b=0;b<this.highlightedBoxes.length;b++)this.highlightedBoxes[b].material.opacity=this.OPACITY_OFF,this.highlightedBoxes[b].material.emissive.setHex(this.colours.LIGHTGREY);this.highlightedBoxes=[]}highlightColumn({r:r,c:c}){for(let b=0;b<this.span;b++)this.boxes[b][r][c].material.opacity=this.OPACITY_ON,this.boxes[b][r][c].material.emissive.setHex(this.colours.DARKGRAY),this.highlightedBoxes.push(this.boxes[b][r][c])}highlightRowX({b:b,r:r}){for(let c=0;c<this.span;c++)this.boxes[b][r][c].material.opacity=this.OPACITY_ON,this.boxes[b][r][c].material.emissive.setHex(this.colours.DARKGRAY),this.highlightedBoxes.push(this.boxes[b][r][c])}highlightRowY({b:b,c:c}){for(let r=0;r<this.span;r++)this.boxes[b][r][c].material.opacity=this.OPACITY_ON,this.boxes[b][r][c].material.emissive.setHex(this.colours.DARKGRAY),this.highlightedBoxes.push(this.boxes[b][r][c])}getPreviewPosition(cube){return{x:cube.position.x,y:cube.position.y,z:cube.position.z}}renderLoop(){if(requestAnimationFrame(()=>this.renderLoop()),this.isLerpingBoxes){console.log("this.span",this.span);for(let b=0;b<this.span;b++)for(let r=0;r<this.span;r++)for(let c=0;c<this.span;c++)b!=this.SPREAD&&r!=this.SPREAD&&c!=this.SPREAD&&Math.abs(this.boxes[b][r][c].position.x-this.boxes[b][r][c].origPos.x*this.explodedMult)<1e-4&&Math.abs(this.boxes[b][r][c].position.y-this.boxes[b][r][c].origPos.y*this.explodedMult)<1e-4&&Math.abs(this.boxes[b][r][c].position.z-this.boxes[b][r][c].origPos.z*this.explodedMult)<1e-4?this.isLerpingBoxes=!1:(this.boxes[b][r][c].position.x+=(this.boxes[b][r][c].origPos.x*this.explodedMult-this.boxes[b][r][c].position.x)/10,this.boxes[b][r][c].position.y+=(this.boxes[b][r][c].origPos.y*this.explodedMult-this.boxes[b][r][c].position.y)/10,this.boxes[b][r][c].position.z+=(this.boxes[b][r][c].origPos.z*this.explodedMult-this.boxes[b][r][c].position.z)/10,this.spheres[b][r][c]&&(this.spheres[b][r][c].position.x+=(this.spheres[b][r][c].origPos.x*this.explodedMult-this.spheres[b][r][c].position.x)/10,this.spheres[b][r][c].position.y+=(this.spheres[b][r][c].origPos.y*this.explodedMult-this.spheres[b][r][c].position.y)/10,this.spheres[b][r][c].position.z+=(this.spheres[b][r][c].origPos.z*this.explodedMult-this.spheres[b][r][c].position.z)/10))}for(let b=0;b<this.span;b++)for(let r=0;r<this.span;r++)for(let c=0;c<this.span;c++)if(this.spheres[b][r][c]&&this.spheres[b][r][c].isLerping){const sphere=this.spheres[b][r][c],{axis:axis}=sphere.newPos;Math.abs(sphere.position[axis]-sphere.newPos[axis])>1e-6?sphere.position[axis]+=(sphere.newPos[axis]-sphere.position[axis])/10:sphere.isLerping=!1}this.camera.lookAt(this.scene.position),this.camera.updateMatrixWorld(),this.renderer.render(this.scene,this.camera),this.raycaster.setFromCamera(this.mouse,this.camera);const intersects=this.raycaster.intersectObjects(this.scene.children,!0);if(intersects.length)if(!this.hoveredObject||this.hoveredObject!=intersects[0].object&&this.hoveredObject!=intersects[0].object.parent){this.hoveredObject=intersects[0].object.data?intersects[0].object:intersects[0].object.parent,this.clearHighlightedBoxes(),this.hoveredObject.data&&this.highlightColumn(this.hoveredObject.data);const{x:x,y:y,z:z}=this.getPreviewPosition(this.hoveredObject);this.previewSphere.position.x=x,this.previewSphere.position.y=y,this.previewSphere.position.z=z,this.previewSphere.material.opacity=.5}else this.mouseIsDown&&!this.hoveredObject.data.isClicked&&(this.hoveredObject.data.isClicked=!0,setTimeout(()=>{this.hoveredObject&&(this.hoveredObject.data.isClicked=!1)},500),this.addPoint(this.hoveredObject.data.b,this.hoveredObject.data.r,this.hoveredObject.data.c,0));else this.clearHighlightedBoxes(),this.previewSphere.material.opacity=0,this.hoveredObject&&(this.hoveredObject.material?(this.hoveredObject.material.emissive.setHex(this.colours.LIGHTGREY),this.hoveredObject.material.opacity=this.OPACITY_OFF,this.hoveredObject.data.isClicked=!1):this.hoveredObject.parent&&(this.hoveredObject.parent.material.emissive.setHex(this.colours.LIGHTGREY),this.hoveredObject.parent.material.opacity=this.OPACITY_OFF,this.hoveredObject.parent.data.isClicked=!1)),this.hoveredObject=null}toggleExploded(){this.explodedMult=1==this.explodedMult?2:1,this.isLerpingBoxes=!0}addPoint(board,row,col,player){this.addSphere(board,row,col,this.playerColours[player].toUpperCase())}render(gameState){this.resetBoard();for(let b=0;b<this.span;b++)for(let r=0;r<this.span;r++)for(let c=0;c<this.span;c++)gameState[b][r][c]&&this.addPoint(b,r,c,gameState[b][r][c])}resetBoard(){for(let b=0;b<this.span;b++)for(let r=0;r<this.span;r++)for(let c=0;c<this.span;c++)this.spheres[b][r][c]&&(this.scene.remove(this.spheres[b][r][c]),this.spheres[b][r][c]=void 0)}rotate(){this.camera.position.x=Math.sin(this.rotation*Math.PI/180)*(1.5*this.BOX_WIDTH)*this.span*2,this.camera.position.z=Math.cos(this.rotation*Math.PI/180)*(1.5*this.BOX_WIDTH)*this.span*2}}"undefined"!=typeof window&&(window.exports=window.exports||{});class GameLogic{constructor({gameState:gameState,gravityEnabled:gravityEnabled=!0,span:span=3,players:players=2,isTraining:isTraining,isMultiplayer:isMultiplayer,aiOpponent:aiOpponent}={}){this.players=[],this.gravityEnabled=gravityEnabled,this.span=parseInt(span),this.numPlayers=parseInt(players),this.isTraining=isTraining,this.aiOpponent=aiOpponent,this.isMultiplayer=isMultiplayer,this.gameState=gameState||this.resetGame(),this.gravity={axis:0,modifier:-1},this.directions={up:0,down:0,left:1,right:1,forward:2,backward:2},this.modifiers={up:1,down:-1,left:-1,right:1,forward:-1,backward:1},this.board=new GameBoard(this),this.aiOpponent?this.players.push(new GamePlayer("AI",0,this)):this.players.push(new GamePlayer("local human",0));for(let p=1;p<players;p++)this.isTraining?this.players.push(new GamePlayer("AI",p,this)):isMultiplayer?this.players.push(new GamePlayer("remote human",p)):this.players.push(new GamePlayer("local human",p));this.playerIndex=Math.floor(Math.random()*players),playerNum.style.color=this.board.playerColours[this.playerIndex],this.players[this.playerIndex].pickMove(this.gameState)}resetGame(){const gameState=[];for(let b=0;b<this.span;b++){const boardGameState=[];for(let r=0;r<this.span;r++){const rowGameState=[];for(let c=0;c<this.span;c++)rowGameState.push(" ");boardGameState.push(rowGameState)}gameState.push(boardGameState)}this.board&&(this.board.resetBoard(),playerNum.style.color=this.board.playerColours[this.playerIndex]),winsDisplay.style.display="none",this.gameState=gameState;for(let p=0;p<this.players.length;p++)"AI"==this.players[p].type&&this.players[p].clearLastState();return gameState}makeMove(p,b,r,c){if(p==this.playerIndex||this.isTraining){if(" "!==this.gameState[b][r][c])return console.log("Illegal move"),this.players[p].reward(-99,this.gameState),void("AI"==this.players[p].type&&this.resetGame());if([b,r,c]=this.applyGravityToMove(b,r,c),this.gameState[b][r][c]=p,this.board.addPoint(b,r,c,p),this.isWinningMove(b,r,c,p))return this.players[p].reward(1,this.gameState),this.players.forEach((player,pi)=>pi!=p&&player.reward(-1,this.gameState)),void(winsDisplay.style.display="inline-block");if(this.isFull())return console.log("Tied game"),void this.players.forEach(player=>player.reward(.25,this.gameState));this.players.forEach((player,pi)=>pi!=p&&player.reward(0,this.gameState)),this.playerIndex=++this.playerIndex%this.players.length,playerNum.style.color=this.board.playerColours[this.playerIndex],winsDisplay.style.display="none",this.players[this.playerIndex].pickMove(this.gameState)}else console.log("NOT your turn!")}isWinningMove(boardIndex,tileY,tileX,player){let match=!1;const max=this.gameState[0].length-1,mid=Math.floor(max/2);if(match=(match=this.gameState[boardIndex][tileY].every(col=>col===player)||this.gameState[boardIndex].every(row=>row[tileX]===player)||(tileX+tileY)%2==0&&(this.gameState[boardIndex].every((row,ri)=>row[ri]===player)||this.gameState[boardIndex].every((row,ri)=>row[max-ri]===player)))||this.gameState.every(board=>board[tileY][tileX]===player))return!0;if(boardIndex!==mid||boardIndex===mid&&(tileY===mid||tileX===mid)){if(match=match||this.gameState.every((board,bi)=>board[max-bi][tileX]===player)||this.gameState.every((board,bi)=>board[bi][tileX]===player)||this.gameState.every((board,bi)=>board[tileY][max-bi]===player)||this.gameState.every((board,bi)=>board[tileY][bi]===player))return!0;this.gameState[mid][mid][mid]===player&&(match=match||this.gameState.every((board,bi)=>board[bi][bi]===player)||this.gameState.every((board,bi)=>board[max-bi][bi]===player)||this.gameState.every((board,bi)=>board[max-bi][max-bi]===player)||this.gameState.every((board,bi)=>board[bi][max-bi]===player))}return match}isFull(){for(let b=0;b<this.span;b++)for(let r=0;r<this.span;r++)for(let c=0;c<this.span;c++)if(" "===this.gameState[b][r][c])return!1;return!0}applyGravityToMove(board,row,col){if(!this.gravityEnabled)return[board,row,col];let counts;switch(this.gravity.axis){case 0:counts=-1==this.gravity.modifier?board:this.span-1-board;for(let i=0;i<counts&&" "===this.gameState[board+this.gravity.modifier][row][col];i++)board+=this.gravity.modifier;break;case 1:counts=-1==this.gravity.modifier?col:this.span-1-col;for(let i=0;i<counts&&" "===this.gameState[board][row][col+this.gravity.modifier];i++)col+=this.gravity.modifier;break;case 2:counts=-1==this.gravity.modifier?row:this.span-1-row;for(let i=0;i<counts&&" "===this.gameState[board][row+this.gravity.modifier][col];i++)row+=this.gravity.modifier}return[board,row,col]}shiftGravity(direction){this.gravity.axis=this.directions[direction],this.gravity.modifier=this.modifiers[direction];const max=Math.abs((-1==this.gravity.modifier?this.span-1:0)-(this.span-1));switch(this.gravity.axis){case 0:for(let r=0;r<this.span;r++)for(let c=0;c<this.span;c++){let i2=0;everyBoard:for(let i=0;i<this.span;i++)if(" "===this.gameState[Math.abs(max-i)][r][c]){for(i2=i+1;i2<this.span;)i2<this.span&&i<this.span&&" "!==this.gameState[Math.abs(max-i2)][r][c]&&(this.gameState[Math.abs(max-i)][r][c]=this.gameState[Math.abs(max-i2)][r][c],this.gameState[Math.abs(max-i2)][r][c]=" ",i+=i2),i2++;break everyBoard}}break;case 1:for(let b=0;b<this.span;b++)for(let r=0;r<this.span;r++){let i2=0;everyColumn:for(let i=0;i<this.span;i++)if(" "===this.gameState[b][r][Math.abs(max-i)]){for(i2=i+1;i2<this.span;)i2<this.span&&i<this.span&&" "!==this.gameState[b][r][Math.abs(max-i2)]&&(this.gameState[b][r][Math.abs(max-i)]=this.gameState[b][r][Math.abs(max-i2)],this.gameState[b][r][Math.abs(max-i2)]=" ",i+=i2),i2++;break everyColumn}}break;case 2:for(let b=0;b<this.span;b++)for(let r=0;r<this.span;r++){let i2=0;everyColumn:for(let i=0;i<this.span;i++)if(" "===this.gameState[b][Math.abs(max-i)][r]){for(i2=i+1;i2<this.span;)i2<this.span&&i<this.span&&" "!==this.gameState[b][Math.abs(max-i2)][r]&&(this.gameState[b][Math.abs(max-i)][r]=this.gameState[b][Math.abs(max-i2)][r],this.gameState[b][Math.abs(max-i2)][r]=" ",i+=i2),i2++;break everyColumn}}}this.board.render(this.gameState),this.checkAll()}checkAll(){let player,match=!1;for(let b=0;b<this.span;b++)for(let r=0;r<this.span;r++)for(let c=0;c<this.span;c++)if(" "!==this.gameState[b][r][c]&&(match=match||this.isWinningMove(b,r,c,this.gameState[b][r][c]))){player=this.gameState[b][r][c];break}match?(playerNum.style.color=this.board.playerColours[player],winsDisplay.style.display="inline-block"):(this.playerIndex=++this.playerIndex%this.players.length,winsDisplay.style.display="none",playerNum.style.color=this.board.playerColours[this.playerIndex])}}"undefined"!=typeof window&&(window.GameLogic=GameLogic),exports.GameLogic=GameLogic;class GamePlayer{constructor(type,playerIndex,game){console.log(`new ${type} player: ${playerIndex}`),this.type=type,this.game=game,this.playerIndex=playerIndex}clearLastState(){for(let b=0;b<this.game.span;b++)for(let r=0;r<this.game.span;r++)for(let c=0;c<this.game.span;c++)this.lastState[b][r][c]=" ";this.lastMove=void 0}pickMove(gameState){"AI"==this.type&&fetch("./getAIMove",{method:"post",body:JSON.stringify({gameState:gameState})}).then(r=>r.json()).then(({move:move})=>{const[b,r,c]=move;this.game.makeMove(this.playerIndex,b,r,c)})}reward(value,gameState){"AI"==this.type&&fetch("./rewardAI",{method:"post",body:JSON.stringify({value:value,gameState:gameState})})}}"undefined"!=typeof window&&(window.GamePlayer=GamePlayer),exports.GamePlayer=GamePlayer;
//# sourceMappingURL=game.min.js.map