<!DOCTYPE html>
<html>
<head>
    <title>Box</title>
    <script src="three.min.js"></script>
    <style>
    body {
        overflow: hidden;
        background-color: white;
    }
    </style>
    <script>
    "use strict"
    window.addEventListener("load", () => {

        const SPAN = 5
        const BOX_WIDTH = 0.5
        const SPREAD = Math.floor(SPAN / 2)
        const SPACING = 1.5
        const SPHERE_RADIUS = 0.2
        const SPHERE_V_COUNT = 50
        const OPACITY_ON = 0.5
        const OPACITY_OFF = 0.25

        let explodedMult = 1
        let isLerping = false
        let radius = (BOX_WIDTH * 1.5) * SPAN * 2
        let rotation = 45
        let mouseIsDown = false
        let theta = 0

        const RED = 0xff0000
        const BLUE = 0x0000ff
        const LIGHTGRAY = 0x999999
        const DARKGRAY = 0x666666
        const WHITE = 0xffffff
        const BLACK = 0x000000

        const scene = new THREE.Scene()
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000)
        const raycaster = new THREE.Raycaster()
        const mouse = new THREE.Vector2()

        const renderer = new THREE.WebGLRenderer({alpha: true, antialias: true})
        renderer.setPixelRatio(window.devicePixelRatio)
        renderer.setSize(window.innerWidth, window.innerHeight)
        document.body.appendChild(renderer.domElement)


        const light = new THREE.DirectionalLight(LIGHTGRAY, 1)
        light.position.set(1, 1, 1).normalize()
        scene.add(light)

        // camera.position.z = 4
        camera.position.y = 2

        let hoveredObject
        const boxes = [...new Array(SPAN)].map(b => [...new Array(SPAN)].map(r => [...new Array(SPAN)]))
        const spheres = [...new Array(SPAN)].map(b => [...new Array(SPAN)].map(r => [...new Array(SPAN)]))
        const boxOutlines = [...new Array(SPAN)].map(b => [...new Array(SPAN)].map(r => [...new Array(SPAN)]))


        const addBox = (b, r, c) => {
            const geometry = new THREE.BoxGeometry(BOX_WIDTH, BOX_WIDTH, BOX_WIDTH)
            const material = new THREE.MeshLambertMaterial({color: DARKGRAY})
            material.opacity = OPACITY_OFF
            material.transparent = true

            const box = new THREE.Mesh(geometry, material)
            box.material.emissive.setHex(LIGHTGRAY)

            box.position.x = (r - SPREAD) * BOX_WIDTH * SPACING
            box.position.y = (b - SPREAD) * BOX_WIDTH * SPACING
            box.position.z = (c - SPREAD) * BOX_WIDTH * SPACING
            box.data = {b, r, c}
            box.origPos = {
                x: box.position.x,
                y: box.position.y,
                z: box.position.z
            }

            scene.add(box)
            boxes[b][r][c] = box

            // Outline stuff
            const outlineGeometry = new THREE.EdgesGeometry(box.geometry)
            const outlineMaterial = new THREE.LineBasicMaterial({color: LIGHTGRAY, linewidth: 40, transparent: true})
            outlineMaterial.opacity = OPACITY_ON
            const outline = new THREE.LineSegments(outlineGeometry, outlineMaterial)
            // box.add(outline)
        }

        const addSphere = (b, r, c, colour) => {
            const sphereGeometry = new THREE.SphereGeometry(SPHERE_RADIUS, SPHERE_V_COUNT, SPHERE_V_COUNT)
            const sphereMaterial = new THREE.MeshLambertMaterial({color: colour})
            const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial)
            sphere.material.emissive.setHex(colour)

            sphere.position.x = (r - SPREAD) * BOX_WIDTH * SPACING
            sphere.position.y = (b - SPREAD) * BOX_WIDTH * SPACING
            sphere.position.z = (c - SPREAD) * BOX_WIDTH * SPACING
            sphere.origPos = {
                x: sphere.position.x,
                y: sphere.position.y,
                z: sphere.position.z
            }

            spheres[b][r][c] = sphere
            scene.add(sphere)
        }


        // Create a render sphere to move around to the correct location
        const previewSphere = (() => {
            const previewSphereGeometry = new THREE.SphereGeometry(SPHERE_RADIUS, SPHERE_V_COUNT, SPHERE_V_COUNT)
            const previewSphereMaterial = new THREE.MeshLambertMaterial({color: RED, transparent: true})
            previewSphereMaterial.opacity = 0
            previewSphereMaterial.emissive.setHex(RED)
            return new THREE.Mesh(previewSphereGeometry, previewSphereMaterial)
        })()
        scene.add(previewSphere)





        for (let b=0; b<SPAN; b++) {
            for (let r=0; r<SPAN; r++) {
                for (let c=0; c<SPAN; c++) {
                    // addBox(c, r, b)
                    addBox(b, r, c)

                    if (Math.random() < 0.1) {
                        addSphere(b, r, c, Math.random() < 0.5 ? RED : BLUE)
                    }
                }
            }
        }

        // addBox(1, 0, 0)

        // TODO
        // const highlightBox
        let highlightedBoxes = []

        const clearHighlightedBoxes = () => {
            for (let b=0; b<highlightedBoxes.length; b++) {
                highlightedBoxes[b].material.opacity = OPACITY_OFF
                highlightedBoxes[b].material.emissive.setHex(LIGHTGRAY)
            }
            highlightedBoxes = []
        }

        const highlightColumn = ({r, c}) => {
            for (let b=0; b<SPAN; b++) {
                boxes[b][r][c].material.opacity = OPACITY_ON
                boxes[b][r][c].material.emissive.setHex(DARKGRAY)
                highlightedBoxes.push(boxes[b][r][c])
            }
        }

        const highlightRowX = ({b, r}) => {
            for (let c=0; c<SPAN; c++) {
                boxes[b][r][c].material.opacity = OPACITY_ON
                boxes[b][r][c].material.emissive.setHex(DARKGRAY)
                highlightedBoxes.push(boxes[b][r][c])
            }
        }

        const highlightRowY = ({b, c}) => {
            for (let r=0; r<SPAN; r++) {
                boxes[b][r][c].material.opacity = OPACITY_ON
                boxes[b][r][c].material.emissive.setHex(DARKGRAY)
                highlightedBoxes.push(boxes[b][r][c])
            }
        }

        const lerpSphere = (sphere, newPos, axis) => {

            console.log("lerpSphere", sphere, newPos, axis)

            switch (axis) {
                case "x":

                    console.log("here", sphere.position.x, newPos.x)
                    while (Math.abs(sphere.position.x - newPos.x) > 1e-6) {
                        console.log("here 1")
                        sphere.position.x += (newPos.x - sphere.position.x) / 100
                    }

                    break
                case "y":
                    break
                case "z":
                    break
            }
        }


        window.shiftSpheres = (axis, direction) => {
            for (let b=0; b<SPAN; b++) {
                for (let r=0; r<SPAN; r++) {
                    for (let c=0; c<SPAN; c++) {
                        if (spheres[b][r][c]) {

                            const sphere = spheres[b][r][c]
                            sphere.isLerping = true
                            sphere.newPos = {}
                            sphere.newPos.direction = direction
                            sphere.newPos.axis = axis
                            sphere.newPos[axis] = sphere.origPos[axis] + (BOX_WIDTH * SPACING) * direction
                        }
                    }
                }
            }
        }


        const getPreviewPosition = cube => {
            const pos = {
                x : cube.position.x,
                y : cube.position.y,
                z : cube.position.z
            }
            return pos
        }


        const render = () => {
            requestAnimationFrame(render)

            theta += 0.1

            // Lerp the boxes into position, when exploded
            if (isLerping) {
                for (let b=0; b<SPAN; b++) {
                    for (let r=0; r<SPAN; r++) {
                        for (let c=0; c<SPAN; c++) {

                            if (b!=SPREAD && r!=SPREAD && c!=SPREAD
                                && Math.abs(boxes[b][r][c].position.x - boxes[b][r][c].origPos.x * explodedMult) < 1e-6
                                && Math.abs(boxes[b][r][c].position.y - boxes[b][r][c].origPos.y * explodedMult) < 1e-6
                                && Math.abs(boxes[b][r][c].position.z - boxes[b][r][c].origPos.z * explodedMult) < 1e-6) {

                                // console.log("SETTING TO FALSE", b, r, c)
                                isLerping = false
                            } else {
                                boxes[b][r][c].position.x += (boxes[b][r][c].origPos.x * explodedMult - boxes[b][r][c].position.x) / 10
                                boxes[b][r][c].position.y += (boxes[b][r][c].origPos.y * explodedMult - boxes[b][r][c].position.y) / 10
                                boxes[b][r][c].position.z += (boxes[b][r][c].origPos.z * explodedMult - boxes[b][r][c].position.z) / 10

                                if (spheres[b][r][c]) {
                                    spheres[b][r][c].position.x += (spheres[b][r][c].origPos.x * explodedMult - spheres[b][r][c].position.x) / 10
                                    spheres[b][r][c].position.y += (spheres[b][r][c].origPos.y * explodedMult - spheres[b][r][c].position.y) / 10
                                    spheres[b][r][c].position.z += (spheres[b][r][c].origPos.z * explodedMult - spheres[b][r][c].position.z) / 10
                                }
                            }
                        }
                    }
                }
            }

            // Lerp the spheres into their new place
            for (let b=0; b<SPAN; b++) {
                for (let r=0; r<SPAN; r++) {
                    for (let c=0; c<SPAN; c++) {

                        if (spheres[b][r][c] && spheres[b][r][c].isLerping) {

                            const sphere = spheres[b][r][c]
                            const axis = sphere.newPos.axis

                            if (Math.abs(sphere.position[axis] - sphere.newPos[axis]) > 1e-6) {
                                sphere.position[axis] += (sphere.newPos[axis] - sphere.position[axis]) / 10
                            } else {
                                sphere.isLerping = false
                            }
                        }
                    }
                }
            }

            camera.lookAt(scene.position)
            camera.updateMatrixWorld()

            renderer.render(scene, camera)
            raycaster.setFromCamera(mouse, camera)

            const intersects = raycaster.intersectObjects(scene.children, true)

            if (intersects.length) {

                // If still hovering on the same thing...
                if (hoveredObject && (hoveredObject==intersects[0].object || hoveredObject==intersects[0].object.parent)) {
                    // do nothing

                    if (mouseIsDown && !hoveredObject.data.isClicked) {
                        hoveredObject.data.isClicked = true
                        setTimeout(() => {
                            if (hoveredObject) {
                                hoveredObject.data.isClicked = false
                            }
                        }, 500)

                        addSphere(hoveredObject.data.b, hoveredObject.data.r, hoveredObject.data.c, Math.random() < 0.5 ? RED : BLUE)
                    }

                } else {

                    // Set the currently hovered over object
                    hoveredObject = intersects[0].object.data ? intersects[0].object : intersects[0].object.parent

                    // TODO, only do this if the highlighted section will change
                    clearHighlightedBoxes()
                    if (hoveredObject.data) {
                        highlightColumn(hoveredObject.data)
                        // highlightRowX(hoveredObject.data)
                        // highlightRowY(hoveredObject.data)
                    }


                    // Render the preview sphere at the correct location
                    const {x, y, z} = getPreviewPosition(hoveredObject)
                    previewSphere.position.x = x
                    previewSphere.position.y = y
                    previewSphere.position.z = z
                    previewSphere.material.opacity = 0.5
                }

            } else {

                clearHighlightedBoxes()
                previewSphere.material.opacity = 0

                if (hoveredObject) {
                    if (hoveredObject.material) {
                        hoveredObject.material.emissive.setHex(LIGHTGRAY)
                        hoveredObject.material.opacity = OPACITY_OFF
                        hoveredObject.data.isClicked = false
                    } else if (hoveredObject.parent) {
                        hoveredObject.parent.material.emissive.setHex(LIGHTGRAY)
                        hoveredObject.parent.material.opacity = OPACITY_OFF
                        hoveredObject.parent.data.isClicked = false
                    }

                }
                hoveredObject = null

            }
        }
        render()
        clearHighlightedBoxes()

        window.toggleExploded = () => {
            explodedMult = explodedMult==1 ? 2 : 1
            isLerping = true
        }


        document.addEventListener("mousemove", event => {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1
            mouse.y = - (event.clientY / window.innerHeight) * 2 + 1
        }, false)
        document.addEventListener("mousedown", () => mouseIsDown = true)
        document.addEventListener("mouseup", () => mouseIsDown = false)
        document.addEventListener("click", () => mouseIsDown = false)

        const setRotation = rotation => {
            camera.position.x = Math.sin(rotation*Math.PI/180) * (BOX_WIDTH * 1.5) * SPAN * 2
            camera.position.z = Math.cos(rotation*Math.PI/180) * (BOX_WIDTH * 1.5) * SPAN * 2
        }
        setRotation(45)

        window.addEventListener("wheel", ({deltaY}) => {
            rotation = (rotation + (deltaY > 0 ? 1 : -1) * 5) % 360
            setRotation(rotation)
        })

        window.addEventListener("keydown", e => {
            if (e.code == "Space") {
                toggleExploded()
            }
        })
    })
    </script>
</head>
<body>

</body>
</html>